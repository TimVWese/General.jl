var documenterSearchIndex = {"docs":
[{"location":"#General.jl-documentation","page":"General.jl documentation","title":"General.jl documentation","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"","category":"page"},{"location":"#Dynamical-objects","page":"General.jl documentation","title":"Dynamical objects","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"count_states(es, i, s)\nIe!(e, v_s, v_d, p, t)\nIStaticEdge(dim)\nSStaticEdge(selection; invalid=0)\nmajority_vertex(i::Integer, dim::Integer; S1=1, S2=2)","category":"page"},{"location":"#General.count_states-Tuple{Any, Any, Any}","page":"General.jl documentation","title":"General.count_states","text":"count_states(es, i, s)\n\nCompute the number of edges in es which have state s at index i.\n\nExamples\n\njulia> count_states([[1,3], [3,3],[1,1]], 2, 3)\n2\n\n\n\n\n\n","category":"method"},{"location":"#General.Ie!-NTuple{5, Any}","page":"General.jl documentation","title":"General.Ie!","text":"Internal dynamics for an identity StaticEdge. Copies the contents of v_s to e.\n\nSee also IStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.IStaticEdge-Tuple{Any}","page":"General.jl documentation","title":"General.IStaticEdge","text":"Constructor for an identity StaticEdgewith dimension dim.\n\nSee also Ie!, SStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.SStaticEdge-Tuple{Any}","page":"General.jl documentation","title":"General.SStaticEdge","text":"SStaticEdge(selection; invalid=0)\n\nConstructor for a StaticEdge with selection dynamics. The edge has dimension equal to length(selection). After evaluation, e[i]==v_s[i] if selection[i]==true and else e[i]==invalid.\n\nSee also combine_graphs, IStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.majority_vertex-Tuple{Integer, Integer}","page":"General.jl documentation","title":"General.majority_vertex","text":"majority_vertex(i::Integer, dim::Integer; U=1, A=2)\n\nConstruct a ODEVertex with binary Watts/threshold dynamics.\n\nArguments\n\ni::Integer: index of the relevant state\ndim::Integer: dimension of the total state\nS1=1: value of state 1\nS2=2: value of state two\n\n\n\n\n\n","category":"method"},{"location":"#Multiplex-networks","page":"General.jl documentation","title":"Multiplex networks","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"combine_graphs(gs::AbstractGraph...)\ncombine_graphs(v_f::Function, gs::AbstractGraph...)","category":"page"},{"location":"#General.combine_graphs-Tuple{Vararg{AbstractGraph, N} where N}","page":"General.jl documentation","title":"General.combine_graphs","text":"static_edges, combined_graph = combine_graphs(gs::AbstractGraph...[; dims=[1], invalid=0])\n\nGenerate the combined_graph which edges are given by the union of the edges of gs. The goal of this function is offer an interface that allows to use multiplex networks in network_dynamics. Each argument represents a single layer. The array static_edges consists of SStaticEdges. The named keyword dims gives the dimension the StaticEdge in each layer ought to have. If length(dims)==1, all dimensions are equal to dim[1]. The selection of static_edges[i] is given by \n\n[[edge ∈ edges(gs[i]) for j in 1:dims[i]] for i in eachindex(gs)]\n\nThe output of the StaticEdge dynamics corresponding to non-existing edges is set to invalid.\n\nSee also SStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.combine_graphs-Tuple{Function, Vararg{AbstractGraph, N} where N}","page":"General.jl documentation","title":"General.combine_graphs","text":"ode_vertices, static_edges, combined_graph =\n    combine_graphs(v_f::Function, gs::AbstractGraph...[; dims=[1]])\n\nGenerate the combined_graph which edges are given by the union of the edges of gs. The goal of this function is offer an interface that allows to use multiplex networks in network_dynamics. Each argument represents a single layer. This method ought to bes used when the vertex dynamics depend on the degree in each layer.\n\nArguments\n\nv_f::Function: a constructor ds -> ODEVertex, where ds[i] is the degree of the corresponding\n\nvertex in gs[i].\n\ngs::AbstractGraph...: graphs to combine\n\nSee also SStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#Network-models","page":"General.jl documentation","title":"Network models","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"configuration_model(degree_seq; allow_collisions=true, max_tries=1000)\nSF_configuration_model(N, γ; min_d=1)\nspatial_network(ps::Matrix; f=x -> x)\nspatial_network(N, d=2; f=x -> x)\npermuted_circle(n, nb_permutations)\nmake_connected!(g::AbstractGraph)","category":"page"},{"location":"#General.configuration_model-Tuple{Any}","page":"General.jl documentation","title":"General.configuration_model","text":"configuration_model(degree_seq; allow_collisions=true, max_tries=1000)\n\nContruct a graph with degree distribution degree_seq using the configuration model. The implementation is based on that of the NetworkX python package.\n\nArguments\n\ndegree_seq::AbstractVector{<:Integer}: degree sequence of the graph\nallow_collisions::Bool: if true, ignore multiple edges between the same pair of nodes and self-loops\nmax_tries::Integer: maximum number of attempts to generate a graph\n\nExamples\n\njulia> configuration_model([3, 3, 3, 3]; allow_collisions=false)\n{4, 6} undirected simple Int64 graph\njulia> configuration_model([0, 0])\n{2, 0} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"#General.SF_configuration_model-Tuple{Any, Any}","page":"General.jl documentation","title":"General.SF_configuration_model","text":"SF_configuration_model(N, γ; min_d=1, allow_collisions=true)\n\nContruct a graph (of size N) with power-law degree distribution (P(k)k^-γ) using the configuration model, with minimal degree min_d.\n\nExamples\n\njulia> SF_configuration_model(4, 2.3; min_d=3, allow_collisions=false)\n{4, 6} undirected simple Int64 graph\njulia> SF_configuration_model(4, 40)\n{4, 2} undirected simple Int64 graph\n\nSee also configuration_model\n\n\n\n\n\n","category":"method"},{"location":"#General.spatial_network-Tuple{Matrix{T} where T}","page":"General.jl documentation","title":"General.spatial_network","text":"spatial_network(ps::Matrix; f=x -> x)\n\nGenerate a spatial network with size(ps, 1) nodes embedded in 01 ^size(ps,2). Edge (ij) is present with probability 1-f(norm(ps[i,:] - ps[j,:])/norm(ones(size(ps,2))))\n\nSee also Graphs.SimpleGraphs.euclidean_graph\n\n\n\n\n\n","category":"method"},{"location":"#General.spatial_network","page":"General.jl documentation","title":"General.spatial_network","text":"g, ps = spatial_network(N[, d=2; f=x -> x])\n\nGenerate a spatial network g with N nodes embedded in 01^d. ps contain the generated points on which the edges are based.\n\nSee also Graphs.SimpleGraphs.euclidean_graph\n\n\n\n\n\n","category":"function"},{"location":"#General.permuted_circle-Tuple{Any, Any}","page":"General.jl documentation","title":"General.permuted_circle","text":"g = permuted_circle(n, nb_permutations)\n\nGenerate a graph with n nodes on a circle (1D periodic grid), i.e. each node is connected to two other nodes. However, the nodes are permuted randomly nb_permutations times, i.e the ordering of the vertices does not correspond to the ordering on the circle anymore.\n\nExamples\n\njulia> g = permuted_circle(4, 1)\n{4, 4} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"#General.make_connected!-Tuple{AbstractGraph}","page":"General.jl documentation","title":"General.make_connected!","text":"make_connected!(g::AbstractGraph)\n\nEnsure g only consists of one component by connecting the largest component to each of the other components with one random edge.\n\nSee also Graphs.connected_components\n\n\n\n\n\n","category":"method"},{"location":"#Degree-distributions","page":"General.jl documentation","title":"Degree distributions","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"degree_distribution(g::Graph; degree_list=nothing)\nconditional_degree_distribution(g::AbstractGraph)\ncombined_degree_distribution(dds::Vector{Tuple{Vector{Int}, Vector{Int}}})\ncombined_degree_distribution(gs::AbstractGraph...)\njoint_distribution(graphs::AbstractGraph...; count_condition = i -> true)","category":"page"},{"location":"#General.degree_distribution-Tuple{SimpleGraph}","page":"General.jl documentation","title":"General.degree_distribution","text":"degree_distribution(g::Graph; degree_list=nothing)\n\nCalculate the degree distribution of a given graph g as a tuple (degree_list, degree_counts), such that degree_counts[i] is the number of nodes with degree degree_list[i]. degree_list can be given as an argument, in that case only the degrees in degree_list are considered.\n\nExamples\n\njulia> get_degree_distribution(grid((3, 3, 3), periodic=true))\n([6,], [27,])\n\n\n\n\n\n","category":"method"},{"location":"#General.conditional_degree_distribution-Tuple{AbstractGraph}","page":"General.jl documentation","title":"General.conditional_degree_distribution","text":"conditional_degree_distribution(g::AbstractGraph)\n\nCalculate the conditional degree distribution of a given graph g. The  conditional degree distribution is a matrix P where each element P[i,j]  represents the probability that a node with degree i is connected to a node  with degree j.\n\n\n\n\n\n","category":"method"},{"location":"#General.combined_degree_distribution-Tuple{Vector{Tuple{Vector{Int64}, Vector{Int64}}}}","page":"General.jl documentation","title":"General.combined_degree_distribution","text":"combined_degree_distribution(dds::Vector{Tuple{Vector{Int}, Vector{Int}}})\n\nCombine the degree distributions of multiple graphs into one. The input is a vector of tuples, where each tuple contains a degree list and a count list.\n\n\n\n\n\n","category":"method"},{"location":"#General.combined_degree_distribution-Tuple{Vararg{AbstractGraph, N} where N}","page":"General.jl documentation","title":"General.combined_degree_distribution","text":"combined_degree_distribution(gs::AbstractGraph...)\n\nCombine the degree distributions of multiple graphs into one.\n\n\n\n\n\n","category":"method"},{"location":"#General.joint_distribution-Tuple{Vararg{AbstractGraph, N} where N}","page":"General.jl documentation","title":"General.joint_distribution","text":"joint_distribution(graphs::AbstractGraph...; count_condition = i -> true)\n\nCalculate the joint degree distribution P ∈ N^{nv(gs[1])^{length(gs)}} for a two layer multiplex network, with each g ∈ gs being a layer. The joint degree distribution is a matrix P where each element P[i1, i2, ...] represents the number of nodes with degree i1 in the first layer, i2 in the second layer, and so on. Only vertices for which count_condition(i) is true are considered.\n\n\n\n\n\n","category":"method"},{"location":"#Graph-IO","page":"General.jl documentation","title":"Graph IO","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"read_from_mtx(filename)\nwrite_to_mtx(filename, g::AbstractGraph)\nread_from_tsv(filename; N::Int64=typemax(Int64), directed=false)","category":"page"},{"location":"#General.read_from_mtx-Tuple{Any}","page":"General.jl documentation","title":"General.read_from_mtx","text":"read_from_mtx(filename)\n\nConstruct a simple graph from a adjacency matrix stored in matrix market format.\n\nSee also write_to_mtx\n\n\n\n\n\n","category":"method"},{"location":"#General.write_to_mtx-Tuple{Any, AbstractGraph}","page":"General.jl documentation","title":"General.write_to_mtx","text":"write_to_mtx(filename)\n\nStore graph g in a matrix market format under filename.\n\nSee also read_from_mtx\n\n\n\n\n\n","category":"method"},{"location":"#General.read_from_tsv-Tuple{Any}","page":"General.jl documentation","title":"General.read_from_tsv","text":"read_from_tsv(filename; N::Int64=typemax(Int64), directed=false)\n\nConstruct a simple graph from a tsv file. The file should contain two columns with the source and destination of each edge.\n\nArguments\n\nfilename: The path to the file\nN: The number of lines to read. If N is smaller than the number of lines in the file, only the first N lines are read.\ndirected: If true, the graph is directed, otherwise it is undirected.\n\nExamples\n\njulia> g = read_from_tsv(\"test.tsv\")\n{4, 3} undirected simple Int64 graph\n\njulia> g = read_from_tsv(\"test.tsv\"; N=2, directed=true)\n{4, 2} directed simple Int64 graph\n\nwith test.tsv:\n\n1\t4\n4   1\n2\t4\n3\t4\n\n\n\n\n\n","category":"method"},{"location":"#Simplicial-complexes","page":"General.jl documentation","title":"Simplicial complexes","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"vietoris_rips(points, epsilon)\nvietoris_rips_mink(n; d=2, min_k=2)\nrandom_simplicial_complex(n, p::Vector; connected=true)","category":"page"},{"location":"#General.vietoris_rips-Tuple{Any, Any}","page":"General.jl documentation","title":"General.vietoris_rips","text":"vietoris_rips(points, epsilon)\n\nConstruct the Vietoris-Rips complex of a set of points in Euclidean space.\n\nArguments\n\npoints: A matrix of size d x n where d is the dimension of the Euclidean space and n is the number of points.\nepsilon: The radius of the balls used to construct the complex. If epsilon is negative, it will be interpreted as Inf.\n\n\n\n\n\n","category":"method"},{"location":"#General.vietoris_rips_mink-Tuple{Any}","page":"General.jl documentation","title":"General.vietoris_rips_mink","text":"vietoris_rips_mink(n; d=2, min_k=2)\n\nConstruct the Vietoris-Rips complex of n random points in d-dimensional Euclidean space. The radius of the balls is chosen such each point is at least part of a min_k dimensional complex.\n\nCurrent implementation and possibly idea do not make much sense!\n\n\n\n\n\n","category":"method"},{"location":"#General.random_simplicial_complex-Tuple{Any, Vector{T} where T}","page":"General.jl documentation","title":"General.random_simplicial_complex","text":"random_simplicial_complex(n, p::Vector)\n\nConstruct a random simplicial complex on n vertices. The probability of including a simplex of dimension k is p[k], if all of its facets are in the complex. The function will give an AssertionError, if the graph is not connected.\n\n\n\n\n\n","category":"method"}]
}
