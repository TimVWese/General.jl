var documenterSearchIndex = {"docs":
[{"location":"#General.jl-documentation","page":"General.jl documentation","title":"General.jl documentation","text":"","category":"section"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"count_states(es, i, s)","category":"page"},{"location":"#General.count_states-Tuple{Any, Any, Any}","page":"General.jl documentation","title":"General.count_states","text":"count_states(es, i, s)\n\nCompute the number of edges in es which have state s at index i.\n\nExamples\n\njulia> count_states([[1,3], [3,3],[1,1]], 2, 3)\n2\n\n\n\n\n\n","category":"method"},{"location":"","page":"General.jl documentation","title":"General.jl documentation","text":"IStaticEdge(dim)\nSStaticEdge(selection; invalid=0)\nIe!(e, v_s, v_d, p, t)\ncombine_graphs(gs::AbstractGraph...)\ncombine_graphs(v_f::Function, gs::AbstractGraph...)\nmajority_vertex(i::Integer, dim::Integer; S1=1, S2=2)\nconfiguration_model(degree_seq; allow_collisions=true, max_tries=1000)\nSF_configuration_model(N, γ; min_d=1)\nspatial_network(ps::Matrix; f=x -> x)\nspatial_network(N, d=2; f=x -> x)\nconditional_degree_distribution(g::AbstractGraph)\nread_from_mtx(filename)\nwrite_to_mtx(filename, g::AbstractGraph)\nmake_connected!(g::AbstractGraph)","category":"page"},{"location":"#General.IStaticEdge-Tuple{Any}","page":"General.jl documentation","title":"General.IStaticEdge","text":"Constructor for an identity StaticEdgewith dimension dim.\n\nSee also Ie!, SStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.SStaticEdge-Tuple{Any}","page":"General.jl documentation","title":"General.SStaticEdge","text":"SStaticEdge(selection; invalid=0)\n\nConstructor for a StaticEdge with selection dynamics. The edge has dimension equal to length(selection). After evaluation, e[i]==v_s[i] if selection[i]==true and else e[i]==invalid.\n\nSee also combine_graphs, IStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.Ie!-NTuple{5, Any}","page":"General.jl documentation","title":"General.Ie!","text":"Internal dynamics for an identity StaticEdge. Copies the contents of v_s to e.\n\nSee also IStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.combine_graphs-Tuple{Vararg{AbstractGraph, N} where N}","page":"General.jl documentation","title":"General.combine_graphs","text":"static_edges, combined_graph = combine_graphs(gs::AbstractGraph...[; dims=[1], invalid=0])\n\nGenerate the combined_graph which edges are given by the union of the edges of gs. The goal of this function is offer an interface that allows to use multiplex networks in network_dynamics. Each argument represents a single layer. The array static_edges consists of SStaticEdges. The named keyword dims gives the dimension the StaticEdge in each layer ought to have. If length(dims)==1, all dimensions are equal to dim[1]. The selection of static_edges[i] is given by \n\n[[edge ∈ edges(gs[i]) for j in 1:dims[i]] for i in eachindex(gs)]\n\nThe output of the StaticEdge dynamics corresponding to non-existing edges is set to invalid.\n\nSee also SStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.combine_graphs-Tuple{Function, Vararg{AbstractGraph, N} where N}","page":"General.jl documentation","title":"General.combine_graphs","text":"ode_vertices, static_edges, combined_graph =\n    combine_graphs(v_f::Function, gs::AbstractGraph...[; dims=[1]])\n\nGenerate the combined_graph which edges are given by the union of the edges of gs. The goal of this function is offer an interface that allows to use multiplex networks in network_dynamics. Each argument represents a single layer. This method ought to bes used when the vertex dynamics depend on the degree in each layer.\n\nArguments\n\nv_f::Function: a constructor ds -> ODEVertex, where ds[i] is the degree of the corresponding\n\nvertex in gs[i].\n\ngs::AbstractGraph...: graphs to combine\n\nSee also SStaticEdge\n\n\n\n\n\n","category":"method"},{"location":"#General.majority_vertex-Tuple{Integer, Integer}","page":"General.jl documentation","title":"General.majority_vertex","text":"majority_vertex(i::Integer, dim::Integer; U=1, A=2)\n\nConstruct a ODEVertex with binary Watts/threshold dynamics.\n\nArguments\n\ni::Integer: index of the relevant state\ndim::Integer: dimension of the total state\nS1=1: value of state 1\nS2=2: value of state two\n\n\n\n\n\n","category":"method"},{"location":"#General.configuration_model-Tuple{Any}","page":"General.jl documentation","title":"General.configuration_model","text":"configuration_model(degree_seq; allow_collisions=true, max_tries=1000)\n\nContruct a graph with degree distribution degree_seq using the configuration model. The implementation is based on that of the NetworkX python package.\n\nArguments\n\ndegree_seq::AbstractVector{<:Integer}: degree sequence of the graph\nallow_collisions::Bool: if true, ignore multiple edges between the same pair of nodes and self-loops\nmax_tries::Integer: maximum number of attempts to generate a graph\n\nExamples\n\njulia> configuration_model([3, 3, 3, 3]; allow_collisions=false)\n{4, 6} undirected simple Int64 graph\njulia> configuration_model([0, 0])\n{2, 0} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"#General.SF_configuration_model-Tuple{Any, Any}","page":"General.jl documentation","title":"General.SF_configuration_model","text":"SF_configuration_model(N, γ; min_d=1, allow_collisions=true)\n\nContruct a graph (of size N) with power-law degree distribution (P(k)k^-γ) using the configuration model, with minimal degree min_d.\n\nExamples\n\njulia> SF_configuration_model(4, 2.3; min_d=3, allow_collisions=false)\n{4, 6} undirected simple Int64 graph\njulia> SF_configuration_model(4, 40)\n{4, 2} undirected simple Int64 graph\n\nSee also configuration_model\n\n\n\n\n\n","category":"method"},{"location":"#General.spatial_network-Tuple{Matrix{T} where T}","page":"General.jl documentation","title":"General.spatial_network","text":"spatial_network(ps::Matrix; f=x -> x)\n\nGenerate a spatial network with size(ps, 1) nodes embedded in 01 ^size(ps,2). Edge (ij) is present with probability 1-f(norm(ps[i,:] - ps[j,:])/norm(ones(size(ps,2))))\n\nSee also Graphs.SimpleGraphs.euclidean_graph\n\n\n\n\n\n","category":"method"},{"location":"#General.spatial_network","page":"General.jl documentation","title":"General.spatial_network","text":"g, ps = spatial_network(N[, d=2; f=x -> x])\n\nGenerate a spatial network g with N nodes embedded in 01^d. ps contain the generated points on which the edges are based.\n\nSee also Graphs.SimpleGraphs.euclidean_graph\n\n\n\n\n\n","category":"function"},{"location":"#General.conditional_degree_distribution-Tuple{AbstractGraph}","page":"General.jl documentation","title":"General.conditional_degree_distribution","text":"conditional_degree_distribution(g::AbstractGraph)\n\nCalculate the conditional degree distribution of a given graph g. The  conditional degree distribution is a matrix P where each element P[i,j]  represents the probability that a node with degree i is connected to a node  with degree j.\n\n\n\n\n\n","category":"method"},{"location":"#General.read_from_mtx-Tuple{Any}","page":"General.jl documentation","title":"General.read_from_mtx","text":"read_from_mtx(filename)\n\nConstruct a simple graph from a adjacency matrix stored in matrix market format.\n\nSee also write_to_mtx\n\n\n\n\n\n","category":"method"},{"location":"#General.write_to_mtx-Tuple{Any, AbstractGraph}","page":"General.jl documentation","title":"General.write_to_mtx","text":"write_to_mtx(filename)\n\nStore graph g in a matrix market format under filename.\n\nSee also read_from_mtx\n\n\n\n\n\n","category":"method"},{"location":"#General.make_connected!-Tuple{AbstractGraph}","page":"General.jl documentation","title":"General.make_connected!","text":"make_connected!(g::AbstractGraph)\n\nEnsure g only consists of one component by connecting the largest component to each of the other components with one random edge.\n\nSee also Graphs.connected_components\n\n\n\n\n\n","category":"method"}]
}
